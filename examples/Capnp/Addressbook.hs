{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DataKinds #-}
{- |
Module: Capnp.Addressbook
Description: Low-level generated module for addressbook.capnp
This module is the generated code for addressbook.capnp, for the
low-level api.
-}
module Capnp.Addressbook where
-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: addressbook.capnp
import Data.Int
import Data.Word
import GHC.Generics (Generic)
import GHC.OverloadedLabels (IsLabel(..))
import Data.Capnp.Bits (Word1)
import qualified Data.Bits
import qualified Data.Maybe
import qualified Data.ByteString
import qualified Data.Capnp.Classes as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.GenHelpers as H'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'
newtype AddressBook msg = AddressBook_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (AddressBook msg) where
    fromStruct = pure . AddressBook_newtype_
instance C'.ToStruct msg (AddressBook msg) where
    toStruct (AddressBook_newtype_ struct) = struct
instance U'.HasMessage (AddressBook msg) where
    type InMessage (AddressBook msg) = msg
    message (AddressBook_newtype_ struct) = U'.message struct
instance U'.MessageDefault (AddressBook msg) where
    messageDefault = AddressBook_newtype_ . U'.messageDefault
instance B'.ListElem msg (AddressBook msg) where
    newtype List msg (AddressBook msg) = List_AddressBook (U'.ListOf msg (U'.Struct msg))
    length (List_AddressBook l) = U'.length l
    index i (List_AddressBook l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (AddressBook msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (AddressBook msg) where
    fromPtr msg ptr = AddressBook_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (AddressBook_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (AddressBook (M'.MutMsg s)) where
    setIndex (AddressBook_newtype_ elt) i (List_AddressBook l) = U'.setIndex elt i l
    newList msg len = List_AddressBook <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (AddressBook (M'.MutMsg s)) where
    new msg = AddressBook_newtype_ <$> U'.allocStruct msg 0 1
instance C'.IsPtr msg (B'.List msg (AddressBook msg)) where
    fromPtr msg ptr = List_AddressBook <$> C'.fromPtr msg ptr
    toPtr msg (List_AddressBook l) = C'.toPtr msg l
get_AddressBook'people :: U'.ReadCtx m msg => AddressBook msg -> m (B'.List msg (Person msg))
get_AddressBook'people (AddressBook_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
instance U'.ReadCtx m msg => IsLabel "people" (H'.Get (AddressBook msg -> m (B'.List msg (Person msg)))) where
    fromLabel = H'.Get $ get_AddressBook'people
has_AddressBook'people :: U'.ReadCtx m msg => AddressBook msg -> m Bool
has_AddressBook'people(AddressBook_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "people" (H'.Has (AddressBook msg -> m Bool)) where
    fromLabel = H'.Has $ has_AddressBook'people
set_AddressBook'people :: U'.RWCtx m s => AddressBook (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person (M'.MutMsg s))) -> m ()
set_AddressBook'people (AddressBook_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
instance U'.RWCtx m s => IsLabel "people" (H'.Set (AddressBook (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person (M'.MutMsg s))) -> m ())) where
    fromLabel = H'.Set set_AddressBook'people
new_AddressBook'people :: U'.RWCtx m s => Int -> AddressBook (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Person (M'.MutMsg s))))
new_AddressBook'people len struct = do
    result <- C'.newList (U'.message struct) len
    set_AddressBook'people struct result
    pure result
newtype Person msg = Person_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person msg) where
    fromStruct = pure . Person_newtype_
instance C'.ToStruct msg (Person msg) where
    toStruct (Person_newtype_ struct) = struct
instance U'.HasMessage (Person msg) where
    type InMessage (Person msg) = msg
    message (Person_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person msg) where
    messageDefault = Person_newtype_ . U'.messageDefault
instance B'.ListElem msg (Person msg) where
    newtype List msg (Person msg) = List_Person (U'.ListOf msg (U'.Struct msg))
    length (List_Person l) = U'.length l
    index i (List_Person l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Person msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Person msg) where
    fromPtr msg ptr = Person_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Person_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Person (M'.MutMsg s)) where
    setIndex (Person_newtype_ elt) i (List_Person l) = U'.setIndex elt i l
    newList msg len = List_Person <$> U'.allocCompositeList msg 1 4 len
instance C'.Allocate s (Person (M'.MutMsg s)) where
    new msg = Person_newtype_ <$> U'.allocStruct msg 1 4
instance C'.IsPtr msg (B'.List msg (Person msg)) where
    fromPtr msg ptr = List_Person <$> C'.fromPtr msg ptr
    toPtr msg (List_Person l) = C'.toPtr msg l
get_Person'id :: U'.ReadCtx m msg => Person msg -> m Word32
get_Person'id (Person_newtype_ struct) = H'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (H'.Get (Person msg -> m Word32)) where
    fromLabel = H'.Get $ get_Person'id
set_Person'id :: U'.RWCtx m s => Person (M'.MutMsg s) -> Word32 -> m ()
set_Person'id (Person_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance U'.RWCtx m s => IsLabel "id" (H'.Set (Person (M'.MutMsg s) -> Word32 -> m ())) where
    fromLabel = H'.Set set_Person'id
get_Person'name :: U'.ReadCtx m msg => Person msg -> m (B'.Text msg)
get_Person'name (Person_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
instance U'.ReadCtx m msg => IsLabel "name" (H'.Get (Person msg -> m (B'.Text msg))) where
    fromLabel = H'.Get $ get_Person'name
has_Person'name :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'name(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (H'.Has (Person msg -> m Bool)) where
    fromLabel = H'.Has $ has_Person'name
set_Person'name :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'name (Person_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
instance U'.RWCtx m s => IsLabel "name" (H'.Set (Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ())) where
    fromLabel = H'.Set set_Person'name
new_Person'name :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'name len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'name struct result
    pure result
get_Person'email :: U'.ReadCtx m msg => Person msg -> m (B'.Text msg)
get_Person'email (Person_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
instance U'.ReadCtx m msg => IsLabel "email" (H'.Get (Person msg -> m (B'.Text msg))) where
    fromLabel = H'.Get $ get_Person'email
has_Person'email :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'email(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "email" (H'.Has (Person msg -> m Bool)) where
    fromLabel = H'.Has $ has_Person'email
set_Person'email :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'email (Person_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
instance U'.RWCtx m s => IsLabel "email" (H'.Set (Person (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ())) where
    fromLabel = H'.Set set_Person'email
new_Person'email :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'email len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'email struct result
    pure result
get_Person'phones :: U'.ReadCtx m msg => Person msg -> m (B'.List msg (Person'PhoneNumber msg))
get_Person'phones (Person_newtype_ struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)
instance U'.ReadCtx m msg => IsLabel "phones" (H'.Get (Person msg -> m (B'.List msg (Person'PhoneNumber msg)))) where
    fromLabel = H'.Get $ get_Person'phones
has_Person'phones :: U'.ReadCtx m msg => Person msg -> m Bool
has_Person'phones(Person_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
instance U'.ReadCtx m msg => IsLabel "phones" (H'.Has (Person msg -> m Bool)) where
    fromLabel = H'.Has $ has_Person'phones
set_Person'phones :: U'.RWCtx m s => Person (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person'PhoneNumber (M'.MutMsg s))) -> m ()
set_Person'phones (Person_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 2 struct
instance U'.RWCtx m s => IsLabel "phones" (H'.Set (Person (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Person'PhoneNumber (M'.MutMsg s))) -> m ())) where
    fromLabel = H'.Set set_Person'phones
new_Person'phones :: U'.RWCtx m s => Int -> Person (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Person'PhoneNumber (M'.MutMsg s))))
new_Person'phones len struct = do
    result <- C'.newList (U'.message struct) len
    set_Person'phones struct result
    pure result
get_Person'employment :: U'.ReadCtx m msg => Person msg -> m (Person'employment msg)
get_Person'employment (Person_newtype_ struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "employment" (H'.Get (Person msg -> m (Person'employment msg))) where
    fromLabel = H'.Get $ get_Person'employment
newtype Person'PhoneNumber msg = Person'PhoneNumber_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person'PhoneNumber msg) where
    fromStruct = pure . Person'PhoneNumber_newtype_
instance C'.ToStruct msg (Person'PhoneNumber msg) where
    toStruct (Person'PhoneNumber_newtype_ struct) = struct
instance U'.HasMessage (Person'PhoneNumber msg) where
    type InMessage (Person'PhoneNumber msg) = msg
    message (Person'PhoneNumber_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person'PhoneNumber msg) where
    messageDefault = Person'PhoneNumber_newtype_ . U'.messageDefault
instance B'.ListElem msg (Person'PhoneNumber msg) where
    newtype List msg (Person'PhoneNumber msg) = List_Person'PhoneNumber (U'.ListOf msg (U'.Struct msg))
    length (List_Person'PhoneNumber l) = U'.length l
    index i (List_Person'PhoneNumber l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Person'PhoneNumber msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Person'PhoneNumber msg) where
    fromPtr msg ptr = Person'PhoneNumber_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Person'PhoneNumber_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Person'PhoneNumber (M'.MutMsg s)) where
    setIndex (Person'PhoneNumber_newtype_ elt) i (List_Person'PhoneNumber l) = U'.setIndex elt i l
    newList msg len = List_Person'PhoneNumber <$> U'.allocCompositeList msg 1 1 len
instance C'.Allocate s (Person'PhoneNumber (M'.MutMsg s)) where
    new msg = Person'PhoneNumber_newtype_ <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Person'PhoneNumber msg)) where
    fromPtr msg ptr = List_Person'PhoneNumber <$> C'.fromPtr msg ptr
    toPtr msg (List_Person'PhoneNumber l) = C'.toPtr msg l
get_Person'PhoneNumber'number :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m (B'.Text msg)
get_Person'PhoneNumber'number (Person'PhoneNumber_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
instance U'.ReadCtx m msg => IsLabel "number" (H'.Get (Person'PhoneNumber msg -> m (B'.Text msg))) where
    fromLabel = H'.Get $ get_Person'PhoneNumber'number
has_Person'PhoneNumber'number :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m Bool
has_Person'PhoneNumber'number(Person'PhoneNumber_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "number" (H'.Has (Person'PhoneNumber msg -> m Bool)) where
    fromLabel = H'.Has $ has_Person'PhoneNumber'number
set_Person'PhoneNumber'number :: U'.RWCtx m s => Person'PhoneNumber (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'PhoneNumber'number (Person'PhoneNumber_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
instance U'.RWCtx m s => IsLabel "number" (H'.Set (Person'PhoneNumber (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ())) where
    fromLabel = H'.Set set_Person'PhoneNumber'number
new_Person'PhoneNumber'number :: U'.RWCtx m s => Int -> Person'PhoneNumber (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'PhoneNumber'number len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'PhoneNumber'number struct result
    pure result
get_Person'PhoneNumber'type_ :: U'.ReadCtx m msg => Person'PhoneNumber msg -> m Person'PhoneNumber'Type
get_Person'PhoneNumber'type_ (Person'PhoneNumber_newtype_ struct) = H'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "type_" (H'.Get (Person'PhoneNumber msg -> m Person'PhoneNumber'Type)) where
    fromLabel = H'.Get $ get_Person'PhoneNumber'type_
set_Person'PhoneNumber'type_ :: U'.RWCtx m s => Person'PhoneNumber (M'.MutMsg s) -> Person'PhoneNumber'Type -> m ()
set_Person'PhoneNumber'type_ (Person'PhoneNumber_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
instance U'.RWCtx m s => IsLabel "type_" (H'.Set (Person'PhoneNumber (M'.MutMsg s) -> Person'PhoneNumber'Type -> m ())) where
    fromLabel = H'.Set set_Person'PhoneNumber'type_
newtype Person'employment msg = Person'employment_newtype_ (U'.Struct msg)
instance C'.FromStruct msg (Person'employment msg) where
    fromStruct = pure . Person'employment_newtype_
instance C'.ToStruct msg (Person'employment msg) where
    toStruct (Person'employment_newtype_ struct) = struct
instance U'.HasMessage (Person'employment msg) where
    type InMessage (Person'employment msg) = msg
    message (Person'employment_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Person'employment msg) where
    messageDefault = Person'employment_newtype_ . U'.messageDefault
data Person'employment' msg
    = Person'employment'unemployed
    | Person'employment'employer (B'.Text msg)
    | Person'employment'school (B'.Text msg)
    | Person'employment'selfEmployed
    | Person'employment'unknown' Word16
get_Person'employment' :: U'.ReadCtx m msg => Person'employment msg -> m (Person'employment' msg)
get_Person'employment' (Person'employment_newtype_ struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "" (H'.Get (Person'employment msg -> m (Person'employment' msg))) where
    fromLabel = H'.Get $ get_Person'employment'
set_Person'employment'unemployed :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> m ()
set_Person'employment'unemployed (Person'employment_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 32 0
set_Person'employment'employer :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'employment'employer(Person'employment_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 32 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 3 struct
new_Person'employment'employer :: U'.RWCtx m s => Int -> Person'employment (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'employment'employer len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'employment'employer struct result
    pure result
set_Person'employment'school :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Person'employment'school(Person'employment_newtype_ struct) value = do
    H'.setWordField struct (2 :: Word16) 0 32 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 3 struct
new_Person'employment'school :: U'.RWCtx m s => Int -> Person'employment (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Person'employment'school len struct = do
    result <- B'.newText (U'.message struct) len
    set_Person'employment'school struct result
    pure result
set_Person'employment'selfEmployed :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> m ()
set_Person'employment'selfEmployed (Person'employment_newtype_ struct) = H'.setWordField struct (3 :: Word16) 0 32 0
set_Person'employment'unknown' :: U'.RWCtx m s => Person'employment (M'.MutMsg s) -> Word16 -> m ()
set_Person'employment'unknown'(Person'employment_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 32 0
instance C'.FromStruct msg (Person'employment' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 32 0
        case tag of
            3 -> pure Person'employment'selfEmployed
            2 -> Person'employment'school <$>  (U'.getPtr 3 struct >>= C'.fromPtr (U'.message struct))
            1 -> Person'employment'employer <$>  (U'.getPtr 3 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Person'employment'unemployed
            _ -> pure $ Person'employment'unknown' tag
data Person'PhoneNumber'Type
    = Person'PhoneNumber'Type'mobile
    | Person'PhoneNumber'Type'home
    | Person'PhoneNumber'Type'work
    | Person'PhoneNumber'Type'unknown' Word16
    deriving(Show,Read,Eq,Generic)
instance Enum Person'PhoneNumber'Type where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord
instance C'.IsWord Person'PhoneNumber'Type where
    fromWord n = go (fromIntegral n :: Word16) where
        go 0 = Person'PhoneNumber'Type'mobile
        go 1 = Person'PhoneNumber'Type'home
        go 2 = Person'PhoneNumber'Type'work
        go tag = Person'PhoneNumber'Type'unknown' (fromIntegral tag)
    toWord Person'PhoneNumber'Type'mobile = 0
    toWord Person'PhoneNumber'Type'home = 1
    toWord Person'PhoneNumber'Type'work = 2
    toWord (Person'PhoneNumber'Type'unknown' tag) = fromIntegral tag
instance B'.ListElem msg Person'PhoneNumber'Type where
    newtype List msg Person'PhoneNumber'Type = List_Person'PhoneNumber'Type (U'.ListOf msg Word16)
    length (List_Person'PhoneNumber'Type l) = U'.length l
    index i (List_Person'PhoneNumber'Type l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s Person'PhoneNumber'Type where
    setIndex elt i (List_Person'PhoneNumber'Type l) = U'.setIndex (fromIntegral $ C'.toWord elt) i l
    newList msg size = List_Person'PhoneNumber'Type <$> U'.allocList16 msg size
instance C'.IsPtr msg (B'.List msg Person'PhoneNumber'Type) where
    fromPtr msg ptr = List_Person'PhoneNumber'Type <$> C'.fromPtr msg ptr
    toPtr msg (List_Person'PhoneNumber'Type l) = C'.toPtr msg l